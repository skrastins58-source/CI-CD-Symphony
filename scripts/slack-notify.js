#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const axios = require('axios');

/**
 * Reads metrics from the JSON file generated by the analysis job.
 * @returns {Object|null} Parsed metrics object or null if not found.
 */
function getMetrics() {
  try {
    // The file is expected to be at the root because of the download-artifact step
    const metricsPath = path.join(process.cwd(), 'reports', 'metrics.json');
    if (fs.existsSync(metricsPath)) {
      const rawData = fs.readFileSync(metricsPath, 'utf8');
      return JSON.parse(rawData);
    }
    console.log('metrics.json not found, proceeding without metrics.');
  } catch (error) {
    console.error('Error reading or parsing metrics.json:', error);
  }
  return null;
}

/**
 * Formats bytes into a human-readable string (KB).
 * @param {number} bytes - The number of bytes.
 * @returns {string} Formatted string (e.g., "123 KB").
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 KB';
  return `${(bytes / 1024).toFixed(2)} KB`;
}

/**
 * Main function to construct and send the Slack notification.
 */
async function sendSlackNotification() {
  const {
    SLACK_WEBHOOK_URL,
    GITHUB_REPOSITORY,
    GITHUB_RUN_ID,
    GITHUB_SERVER_URL,
    GITHUB_WORKFLOW,
    GITHUB_EVENT_NAME,
    JOB_STATUS,
    SLACK_ONLY_FAILURES
  } = process.env;

  if (!SLACK_WEBHOOK_URL) {
    console.log('SLACK_WEBHOOK_URL not found. Skipping Slack notification.');
    return;
  }

  const isSuccess = JOB_STATUS === 'success';

  if (SLACK_ONLY_FAILURES === 'true' && isSuccess) {
    console.log('Job succeeded and SLACK_ONLY_FAILURES is true. Skipping notification.');
    return;
  }

  const metrics = getMetrics();
  const statusText = isSuccess ? 'Success' : 'Failed';
  const statusEmoji = isSuccess ? '‚úÖ' : '‚ùå';
  const color = isSuccess ? '#28a745' : '#dc3545';
  const runUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;

  const blocks = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: `${statusEmoji} CI/CD Symphony: ${GITHUB_WORKFLOW} - ${statusText}`,
        emoji: true,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `A *${GITHUB_EVENT_NAME}* event triggered the *${GITHUB_WORKFLOW}* workflow.`,
      },
    },
  ];

  if (metrics) {
    blocks.push({
      type: 'section',
      fields: [
        { type: 'mrkdwn', text: `*üìà Performance:*\n${metrics.performance.toFixed(2)}%` },
        { type: 'mrkdwn', text: `*üõ°Ô∏è Coverage:*\n${metrics.coverage.toFixed(2)}%` },
        { type: 'mrkdwn', text: `*üì¶ Bundle Size:*\n${formatBytes(metrics.bundleSize)}` },
      ],
    });
  } else {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '_Metrics data not available for this run._',
      },
    });
}

  blocks.push(
    {
      type: 'divider',
    },
    {
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: {
            type: 'plain_text',
            text: 'View Workflow Run',
            emoji: true,
          },
          url: runUrl,
          style: isSuccess ? 'primary' : 'danger',
        },
      ],
    }
  );

  const payload = {
    attachments: [
      {
        color: color,
        blocks: blocks,
      },
    ],
  };

  try {
    await axios.post(SLACK_WEBHOOK_URL, payload);
    console.log('Slack notification sent successfully!');
  } catch (error) {
    console.error('Error sending Slack notification:', error.message);
    process.exit(1);
  }
}

sendSlackNotification();